import { abortableSource } from 'abortable-iterator';
import { logger } from '@libp2p/logger';
const log = logger('libp2p:stream:converter');
/**
 * Convert a duplex iterable into a MultiaddrConnection.
 * https://github.com/libp2p/interface-transport#multiaddrconnection
 */
export function streamToMaConnection(props, options = {}) {
    const { stream, remoteAddr } = props;
    const { sink, source } = stream;
    const mapSource = (async function* () {
        for await (const list of source) {
            yield* list;
        }
    }());
    const maConn = {
        async sink(source) {
            if (options.signal != null) {
                source = abortableSource(source, options.signal);
            }
            try {
                await sink(source);
                await close();
            }
            catch (err) {
                // If aborted we can safely ignore
                if (err.type !== 'aborted') {
                    // If the source errored the socket will already have been destroyed by
                    // toIterable.duplex(). If the socket errored it will already be
                    // destroyed. There's nothing to do here except log the error & return.
                    log(err);
                }
            }
        },
        source: (options.signal != null) ? abortableSource(mapSource, options.signal) : mapSource,
        remoteAddr,
        /** @type {Timeline} */
        timeline: { open: Date.now(), close: undefined },
        async close() {
            await sink(async function* () {
                yield new Uint8Array(0);
            }());
            await close();
        }
    };
    async function close() {
        if (maConn.timeline.close == null) {
            maConn.timeline.close = Date.now();
        }
        return await Promise.resolve();
    }
    return maConn;
}
//# sourceMappingURL=stream-to-ma-conn.js.map