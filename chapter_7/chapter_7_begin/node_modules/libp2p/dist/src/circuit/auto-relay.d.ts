import type { PeerId } from '@libp2p/interface-peer-id';
import type { AddressSorter, PeerProtocolsChangeData } from '@libp2p/interface-peer-store';
import type { Connection } from '@libp2p/interface-connection';
import type { RelayComponents } from './index.js';
export interface AutoRelayInit {
    addressSorter?: AddressSorter;
    maxListeners?: number;
    onError?: (error: Error, msg?: string) => void;
}
export declare class AutoRelay {
    private readonly components;
    private readonly addressSorter;
    private readonly maxListeners;
    private readonly listenRelays;
    private readonly onError;
    constructor(components: RelayComponents, init: AutoRelayInit);
    /**
     * Check if a peer supports the relay protocol.
     * If the protocol is not supported, check if it was supported before and remove it as a listen relay.
     * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if
     * inside the threshold.
     */
    _onProtocolChange(evt: CustomEvent<PeerProtocolsChangeData>): Promise<void>;
    /**
     * Peer disconnects
     */
    _onPeerDisconnected(evt: CustomEvent<Connection>): void;
    /**
     * Attempt to listen on the given relay connection
     */
    _addListenRelay(connection: Connection, id: string): Promise<void>;
    /**
     * Remove listen relay
     */
    _removeListenRelay(id: string): Promise<void>;
    /**
     * Try to listen on available hop relay connections.
     * The following order will happen while we do not have enough relays.
     * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.
     * 2. Dial and try to listen on the peers we know that support hop but are not connected.
     * 3. Search the network.
     */
    _listenOnAvailableHopRelays(peersToIgnore?: string[]): Promise<void>;
    _tryToListenOnRelay(peerId: PeerId): Promise<void>;
}
//# sourceMappingURL=auto-relay.d.ts.map