import { EventEmitter } from '@libp2p/interfaces/events';
import type { MovingAverages, Stats, TransferStats } from '@libp2p/interface-metrics';
export interface StatsEvents {
    'update': CustomEvent<TransferStats>;
}
export interface StatsInit {
    enabled: boolean;
    initialCounters: ['dataReceived', 'dataSent'];
    movingAverageIntervals: number[];
    computeThrottleMaxQueueSize: number;
    computeThrottleTimeout: number;
}
export declare class DefaultStats extends EventEmitter<StatsEvents> implements Stats {
    private readonly enabled;
    queue: Array<[string, number, number]>;
    private stats;
    private frequencyLastTime;
    private frequencyAccumulators;
    private movingAverages;
    private timeout?;
    private readonly computeThrottleMaxQueueSize;
    private readonly computeThrottleTimeout;
    private readonly movingAverageIntervals;
    /**
     * A queue based manager for stat processing
     */
    constructor(init: StatsInit);
    /**
     * Initializes the internal timer if there are items in the queue. This
     * should only need to be called if `Stats.stop` was previously called, as
     * `Stats.push` will also start the processing
     */
    start(): void;
    /**
     * Stops processing and computing of stats by clearing the internal
     * timer
     */
    stop(): void;
    /**
     * Returns a clone of the current stats.
     */
    getSnapshot(): TransferStats;
    /**
     * Returns a clone of the internal movingAverages
     */
    getMovingAverages(): MovingAverages;
    /**
     * Pushes the given operation data to the queue, along with the
     * current Timestamp, then resets the update timer.
     */
    push(counter: string, inc: number): void;
    /**
     * Resets the timeout for triggering updates.
     */
    _resetComputeTimeout(): void;
    /**
     * Calculates and returns the timeout for the next update based on
     * the urgency of the update.
     */
    _nextTimeout(): number;
    /**
     * If there are items in the queue, they will will be processed and
     * the frequency for all items will be updated based on the Timestamp
     * of the last item in the queue. The `update` event will also be emitted
     * with the latest stats.
     *
     * If there are no items in the queue, no action is taken.
     */
    _update(): void;
    /**
     * For each key in the stats, the frequency and moving averages
     * will be updated via Stats._updateFrequencyFor based on the time
     * difference between calls to this method.
     */
    _updateFrequency(latestTime: number): void;
    /**
     * Updates the `movingAverages` for the given `key` and also
     * resets the `frequencyAccumulator` for the `key`.
     */
    _updateFrequencyFor(key: 'dataReceived' | 'dataSent', timeDiffMS: number, latestTime: number): void;
    /**
     * For the given operation, `op`, the stats and `frequencyAccumulator`
     * will be updated or initialized if they don't already exist.
     */
    _applyOp(op: [string, number, number]): void;
}
//# sourceMappingURL=stats.d.ts.map