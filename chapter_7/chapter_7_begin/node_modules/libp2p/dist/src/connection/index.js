import errCode from 'err-code';
import { OPEN, CLOSING, CLOSED } from '@libp2p/interface-connection/status';
import { symbol } from '@libp2p/interface-connection';
import { logger } from '@libp2p/logger';
const log = logger('libp2p:connection');
/**
 * An implementation of the js-libp2p connection.
 * Any libp2p transport should use an upgrader to return this connection.
 */
export class ConnectionImpl {
    /**
     * An implementation of the js-libp2p connection.
     * Any libp2p transport should use an upgrader to return this connection.
     */
    constructor(init) {
        const { remoteAddr, remotePeer, newStream, close, getStreams, stat } = init;
        this.id = `${(parseInt(String(Math.random() * 1e9))).toString(36)}${Date.now()}`;
        this.remoteAddr = remoteAddr;
        this.remotePeer = remotePeer;
        this.stat = {
            ...stat,
            status: OPEN
        };
        this._newStream = newStream;
        this._close = close;
        this._getStreams = getStreams;
        this.tags = [];
        this._closing = false;
    }
    get [Symbol.toStringTag]() {
        return 'Connection';
    }
    get [symbol]() {
        return true;
    }
    /**
     * Get all the streams of the muxer
     */
    get streams() {
        return this._getStreams();
    }
    /**
     * Create a new stream from this connection
     */
    async newStream(protocols, options) {
        if (this.stat.status === CLOSING) {
            throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED');
        }
        if (this.stat.status === CLOSED) {
            throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED');
        }
        if (!Array.isArray(protocols)) {
            protocols = [protocols];
        }
        const stream = await this._newStream(protocols, options);
        stream.stat.direction = 'outbound';
        return stream;
    }
    /**
     * Add a stream when it is opened to the registry
     */
    addStream(stream) {
        stream.stat.direction = 'inbound';
    }
    /**
     * Remove stream registry after it is closed
     */
    removeStream(id) {
    }
    /**
     * Close the connection
     */
    async close() {
        if (this.stat.status === CLOSED || this._closing) {
            return;
        }
        this.stat.status = CLOSING;
        // close all streams - this can throw if we're not multiplexed
        try {
            this.streams.forEach(s => s.close());
        }
        catch (err) {
            log.error(err);
        }
        // Close raw connection
        this._closing = true;
        await this._close();
        this._closing = false;
        this.stat.timeline.close = Date.now();
        this.stat.status = CLOSED;
    }
}
export function createConnection(init) {
    return new ConnectionImpl(init);
}
//# sourceMappingURL=index.js.map