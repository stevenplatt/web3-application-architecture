import type { Multiaddr, Resolver } from '@multiformats/multiaddr';
import { TimeoutController } from 'timeout-abort-controller';
import { DialRequest } from './dial-request.js';
import type { Connection, ConnectionGater } from '@libp2p/interface-connection';
import type { AbortOptions } from '@libp2p/interfaces';
import type { Startable } from '@libp2p/interfaces/startable';
import type { PeerId } from '@libp2p/interface-peer-id';
import type { AddressSorter, PeerStore } from '@libp2p/interface-peer-store';
import type { ComponentMetricsTracker, Metrics } from '@libp2p/interface-metrics';
import type { Dialer } from '@libp2p/interface-connection-manager';
import type { TransportManager } from '@libp2p/interface-transport';
export interface DialTarget {
    id: string;
    addrs: Multiaddr[];
}
export interface PendingDial {
    dialRequest: DialRequest;
    controller: TimeoutController;
    promise: Promise<Connection>;
    destroy: () => void;
}
export interface PendingDialTarget {
    resolve: (value: any) => void;
    reject: (err: Error) => void;
}
export interface DialerInit {
    /**
     * Sort the known addresses of a peer before trying to dial
     */
    addressSorter?: AddressSorter;
    /**
     * Number of max concurrent dials
     */
    maxParallelDials?: number;
    /**
     * Number of max addresses to dial for a given peer
     */
    maxAddrsToDial?: number;
    /**
     * How long a dial attempt is allowed to take
     */
    dialTimeout?: number;
    /**
     * Number of max concurrent dials per peer
     */
    maxDialsPerPeer?: number;
    /**
     * Multiaddr resolvers to use when dialing
     */
    resolvers?: Record<string, Resolver>;
    metrics?: ComponentMetricsTracker;
}
export interface DefaultDialerComponents {
    peerId: PeerId;
    metrics?: Metrics;
    peerStore: PeerStore;
    transportManager: TransportManager;
    connectionGater: ConnectionGater;
}
export declare class DefaultDialer implements Startable, Dialer {
    private readonly components;
    private readonly addressSorter;
    private readonly maxAddrsToDial;
    private readonly timeout;
    private readonly maxDialsPerPeer;
    tokens: number[];
    pendingDials: Map<string, PendingDial>;
    pendingDialTargets: Map<string, PendingDialTarget>;
    private started;
    constructor(components: DefaultDialerComponents, init?: DialerInit);
    isStarted(): boolean;
    start(): Promise<void>;
    /**
     * Clears any pending dials
     */
    stop(): Promise<void>;
    /**
     * Connects to a given `peer` by dialing all of its known addresses.
     * The dial to the first address that is successfully able to upgrade a connection
     * will be used.
     */
    dial(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<Connection>;
    /**
     * Connects to a given `peer` by dialing all of its known addresses.
     * The dial to the first address that is successfully able to upgrade a connection
     * will be used.
     */
    _createCancellableDialTarget(peer: PeerId, options: AbortOptions): Promise<DialTarget>;
    /**
     * Creates a DialTarget. The DialTarget is used to create and track
     * the DialRequest to a given peer.
     * If a multiaddr is received it should be the first address attempted.
     * Multiaddrs not supported by the available transports will be filtered out.
     */
    _createDialTarget(peer: PeerId, options: AbortOptions): Promise<DialTarget>;
    /**
     * Creates a PendingDial that wraps the underlying DialRequest
     */
    _createPendingDial(dialTarget: DialTarget, options?: AbortOptions): PendingDial;
    getTokens(num: number): number[];
    releaseToken(token: number): void;
    /**
     * Resolve multiaddr recursively
     */
    _resolve(ma: Multiaddr, options: AbortOptions): Promise<Multiaddr[]>;
    /**
     * Resolve a given multiaddr. If this fails, an empty array will be returned
     */
    _resolveRecord(ma: Multiaddr, options: AbortOptions): Promise<Multiaddr[]>;
}
//# sourceMappingURL=index.d.ts.map