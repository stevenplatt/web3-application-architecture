import { Uint8ArrayList } from 'uint8arraylist';
import defer from 'p-defer';
const DEFAULT_BATCH_SIZE = 1024 * 1024;
const DEFAULT_SERIALIZE = (buf, list) => list.append(buf);
async function* batchedBytes(source, options = {}) {
    let buffer = new Uint8ArrayList();
    let ended = false;
    let deferred = defer();
    let size = Number(options.size ?? DEFAULT_BATCH_SIZE);
    if (isNaN(size) || size === 0 || size < 0) {
        size = DEFAULT_BATCH_SIZE;
    }
    const yieldAfter = options.yieldAfter ?? 0;
    const serialize = options.serialize ?? DEFAULT_SERIALIZE;
    void Promise.resolve().then(async () => {
        try {
            let timeout;
            for await (const buf of source) {
                serialize(buf, buffer);
                if (buffer.byteLength >= size) {
                    clearTimeout(timeout);
                    deferred.resolve();
                    continue;
                }
                timeout = setTimeout(() => {
                    deferred.resolve();
                }, yieldAfter);
            }
            clearTimeout(timeout);
            deferred.resolve();
        }
        catch (err) {
            deferred.reject(err);
        }
        finally {
            ended = true;
        }
    });
    while (!ended) { // eslint-disable-line no-unmodified-loop-condition
        await deferred.promise;
        deferred = defer();
        if (buffer.byteLength > 0) {
            const b = buffer;
            buffer = new Uint8ArrayList();
            yield b.subarray();
        }
    }
}
export default batchedBytes;
//# sourceMappingURL=index.js.map