import errCode from 'err-code';
import { messages, codes } from '../errors.js';
import { storeAddresses, uniquePeers, requirePeers } from './utils.js';
import drain from 'it-drain';
import merge from 'it-merge';
import { pipe } from 'it-pipe';
export class CompoundContentRouting {
    constructor(components, init) {
        this.routers = init.routers ?? [];
        this.started = false;
        this.components = components;
    }
    isStarted() {
        return this.started;
    }
    async start() {
        this.started = true;
    }
    async stop() {
        this.started = false;
    }
    /**
     * Iterates over all content routers in parallel to find providers of the given key
     */
    async *findProviders(key, options = {}) {
        if (this.routers.length === 0) {
            throw errCode(new Error('No content this.routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        yield* pipe(merge(...this.routers.map(router => router.findProviders(key, options))), (source) => storeAddresses(source, this.components.peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
    }
    /**
     * Iterates over all content routers in parallel to notify it is
     * a provider of the given key
     */
    async provide(key, options = {}) {
        if (this.routers.length === 0) {
            throw errCode(new Error('No content routers available'), codes.ERR_NO_ROUTERS_AVAILABLE);
        }
        await Promise.all(this.routers.map(async (router) => await router.provide(key, options)));
    }
    /**
     * Store the given key/value pair in the available content routings
     */
    async put(key, value, options) {
        if (!this.isStarted()) {
            throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        const dht = this.components.dht;
        if (dht != null) {
            await drain(dht.put(key, value, options));
        }
    }
    /**
     * Get the value to the given key.
     * Times out after 1 minute by default.
     */
    async get(key, options) {
        if (!this.isStarted()) {
            throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        const dht = this.components.dht;
        if (dht != null) {
            for await (const event of dht.get(key, options)) {
                if (event.name === 'VALUE') {
                    return event.value;
                }
            }
        }
        throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
    }
    /**
     * Get the `n` values to the given key without sorting
     */
    async *getMany(key, nVals, options) {
        if (!this.isStarted()) {
            throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        if (nVals == null || nVals === 0) {
            return;
        }
        let gotValues = 0;
        const dht = this.components.dht;
        if (dht != null) {
            for await (const event of dht.get(key, options)) {
                if (event.name === 'VALUE') {
                    yield { from: event.from, val: event.value };
                    gotValues++;
                    if (gotValues === nVals) {
                        break;
                    }
                }
            }
        }
        if (gotValues === 0) {
            throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
        }
    }
}
//# sourceMappingURL=index.js.map