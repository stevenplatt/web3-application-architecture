import type { PeerId } from '@libp2p/interface-peer-id';
import type { PeerRouting } from '@libp2p/interface-peer-routing';
import type { AbortOptions } from '@libp2p/interfaces';
import type { Startable } from '@libp2p/interfaces/startable';
import type { PeerInfo } from '@libp2p/interface-peer-info';
import type { PeerStore } from '@libp2p/interface-peer-store';
export interface RefreshManagerInit {
    /**
     * Whether to enable the Refresh manager
     */
    enabled?: boolean;
    /**
     * Boot delay to start the Refresh Manager (in ms)
     */
    bootDelay?: number;
    /**
     * Interval between each Refresh Manager run (in ms)
     */
    interval?: number;
    /**
     * How long to let each refresh run (in ms)
     */
    timeout?: number;
}
export interface PeerRoutingInit {
    routers?: PeerRouting[];
    refreshManager?: RefreshManagerInit;
}
export interface DefaultPeerRoutingComponents {
    peerId: PeerId;
    peerStore: PeerStore;
}
export declare class DefaultPeerRouting implements PeerRouting, Startable {
    private readonly components;
    private readonly routers;
    private readonly refreshManagerInit;
    private timeoutId?;
    private started;
    private abortController?;
    constructor(components: DefaultPeerRoutingComponents, init: PeerRoutingInit);
    isStarted(): boolean;
    /**
     * Start peer routing service.
     */
    start(): Promise<void>;
    /**
     * Recurrent task to find closest peers and add their addresses to the Address Book.
     */
    _findClosestPeersTask(): Promise<void>;
    /**
     * Stop peer routing service.
     */
    stop(): Promise<void>;
    /**
     * Iterates over all peer routers in parallel to find the given peer
     */
    findPeer(id: PeerId, options?: AbortOptions): Promise<PeerInfo>;
    /**
     * Attempt to find the closest peers on the network to the given key
     */
    getClosestPeers(key: Uint8Array, options?: AbortOptions): AsyncIterable<PeerInfo>;
}
//# sourceMappingURL=peer-routing.d.ts.map