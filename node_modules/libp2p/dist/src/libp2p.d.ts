import type { AbortOptions } from '@libp2p/interfaces';
import { EventEmitter } from '@libp2p/interfaces/events';
import { Multiaddr } from '@multiformats/multiaddr';
import { KeyChain } from './keychain/index.js';
import { IdentifyService } from './identify/index.js';
import { FetchService } from './fetch/index.js';
import { PingService } from './ping/index.js';
import type { Components } from './components.js';
import type { PeerId } from '@libp2p/interface-peer-id';
import type { Connection } from '@libp2p/interface-connection';
import type { PeerRouting } from '@libp2p/interface-peer-routing';
import type { ContentRouting } from '@libp2p/interface-content-routing';
import type { PubSub } from '@libp2p/interface-pubsub';
import type { Registrar, StreamHandler, StreamHandlerOptions, Topology } from '@libp2p/interface-registrar';
import type { ConnectionManager } from '@libp2p/interface-connection-manager';
import type { PeerInfo } from '@libp2p/interface-peer-info';
import type { Libp2p, Libp2pEvents, Libp2pInit, Libp2pOptions } from './index.js';
import type { PeerStore } from '@libp2p/interface-peer-store';
import type { DualDHT } from '@libp2p/interface-dht';
import type { Metrics } from '@libp2p/interface-metrics';
export declare class Libp2pNode extends EventEmitter<Libp2pEvents> implements Libp2p {
    peerId: PeerId;
    dht: DualDHT;
    pubsub: PubSub;
    identifyService: IdentifyService;
    fetchService: FetchService;
    pingService: PingService;
    components: Components;
    peerStore: PeerStore;
    contentRouting: ContentRouting;
    peerRouting: PeerRouting;
    keychain: KeyChain;
    connectionManager: ConnectionManager;
    registrar: Registrar;
    metrics?: Metrics;
    private started;
    private readonly services;
    constructor(init: Libp2pInit);
    private configureComponent;
    /**
     * Starts the libp2p node and all its subsystems
     */
    start(): Promise<void>;
    /**
     * Stop the libp2p node by closing its listeners and open connections
     */
    stop(): Promise<void>;
    isStarted(): boolean;
    getConnections(peerId?: PeerId): Connection[];
    getPeers(): PeerId[];
    dial(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<Connection>;
    dialProtocol(peer: PeerId | Multiaddr, protocols: string | string[], options?: AbortOptions): Promise<import("@libp2p/interface-connection").Stream>;
    getMultiaddrs(): Multiaddr[];
    getProtocols(): string[];
    hangUp(peer: PeerId | Multiaddr): Promise<void>;
    /**
     * Get the public key for the given peer id
     */
    getPublicKey(peer: PeerId, options?: AbortOptions): Promise<Uint8Array>;
    fetch(peer: PeerId | Multiaddr, key: string, options?: AbortOptions): Promise<Uint8Array | null>;
    ping(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<number>;
    handle(protocols: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>;
    unhandle(protocols: string[] | string): Promise<void>;
    register(protocol: string, topology: Topology): Promise<string>;
    unregister(id: string): void;
    /**
     * Called whenever peer discovery services emit `peer` events.
     * Known peers may be emitted.
     */
    onDiscoveryPeer(evt: CustomEvent<PeerInfo>): void;
}
/**
 * Returns a new Libp2pNode instance - this exposes more of the internals than the
 * libp2p interface and is useful for testing and debugging.
 */
export declare function createLibp2pNode(options: Libp2pOptions): Promise<Libp2pNode>;
//# sourceMappingURL=libp2p.d.ts.map