import { toString } from 'uint8arrays/to-string';
import { PubSubBaseProtocol } from '@libp2p/pubsub';
import { multicodec } from './config.js';
import { SimpleTimeCache } from './cache.js';
import { logger } from '@libp2p/logger';
import { RPC } from './message/rpc.js';
const log = logger('libp2p:floodsub');
export { multicodec };
/**
 * FloodSub (aka dumbsub is an implementation of pubsub focused on
 * delivering an API for Publish/Subscribe, but with no CastTree Forming
 * (it just floods the network).
 */
export class FloodSub extends PubSubBaseProtocol {
    constructor(components, init) {
        super(components, {
            ...init,
            canRelayMessage: true,
            multicodecs: [multicodec]
        });
        /**
         * Cache of seen messages
         *
         * @type {TimeCache}
         */
        this.seenCache = new SimpleTimeCache({
            validityMs: init?.seenTTL ?? 30000
        });
    }
    /**
     * Decode a Uint8Array into an RPC object
     */
    decodeRpc(bytes) {
        return RPC.decode(bytes);
    }
    /**
     * Encode an RPC object into a Uint8Array
     */
    encodeRpc(rpc) {
        return RPC.encode(rpc);
    }
    decodeMessage(bytes) {
        return RPC.Message.decode(bytes);
    }
    encodeMessage(rpc) {
        return RPC.Message.encode(rpc);
    }
    /**
     * Process incoming message
     * Extends base implementation to check router cache.
     */
    async processMessage(from, message) {
        // Check if I've seen the message, if yes, ignore
        const seqno = await super.getMsgId(message);
        const msgIdStr = toString(seqno, 'base64');
        if (this.seenCache.has(msgIdStr)) {
            return;
        }
        this.seenCache.put(msgIdStr, true);
        await super.processMessage(from, message);
    }
    /**
     * Publish message created. Forward it to the peers.
     */
    async publishMessage(from, message) {
        const peers = this.getSubscribers(message.topic);
        const recipients = [];
        if (peers == null || peers.length === 0) {
            log('no peers are subscribed to topic %s', message.topic);
            return { recipients };
        }
        peers.forEach(id => {
            if (this.components.peerId.equals(id)) {
                log('not sending message on topic %s to myself', message.topic);
                return;
            }
            if (id.equals(from)) {
                log('not sending message on topic %s to sender %p', message.topic, id);
                return;
            }
            log('publish msgs on topics %s %p', message.topic, id);
            recipients.push(id);
            this.send(id, { messages: [message] });
        });
        return { recipients };
    }
}
export function floodsub(init = {}) {
    return (components) => new FloodSub(components, init);
}
//# sourceMappingURL=index.js.map